/**
 * ZK Utilities for GridTokenX Privacy
 * 
 * Provides high-level TypeScript wrappers for Ristretto commitments
 * and Zero-Knowledge proofs generated by the WASM module.
 */

import { getWasmExports, ZkCommitment, ZkRangeProof, ZkTransferProof } from './wasm-bridge';

/**
 * Helper to pass Uint8Array to WASM memory
 */
function passArrayToWasm(array: Uint8Array, malloc: Function, memory: WebAssembly.Memory): number {
    const ptr = malloc(array.length, 1);
    const mem = new Uint8Array(memory.buffer);
    mem.set(array, ptr);
    return ptr;
}

/**
 * Helper to get object from WASM retptr (assuming JSON serialized for simplicity)
 * Note: Our WASM uses serde_wasm_bindgen which usually returns JsValue directly
 * if using the generated JS. But if calling raw exports, we need care.
 */
// Actually, since we want to be robust, let's use the generated JS wrapper if possible.
// But the project currently uses a manual loader.

export async function createCommitment(value: number, blinding: Uint8Array): Promise<ZkCommitment> {
    // For now, let's dynamically import the generated JS to avoid duplicating logic
    // This is the cleanest way to handle complex types.
    const pkg = await import('./wasm-generated/gridtokenx_wasm.js');
    await pkg.default(); // Ensure init
    return pkg.create_commitment(BigInt(value), blinding);
}

export async function createRangeProof(amount: number, blinding: Uint8Array): Promise<ZkRangeProof> {
    const pkg = await import('./wasm-generated/gridtokenx_wasm.js');
    await pkg.default();
    const proof = pkg.create_range_proof(BigInt(amount), blinding);
    return {
        proof_data: Array.from(proof.proof_data),
        commitment: proof.commitment
    };
}

export async function createTransferProof(
    amount: number,
    balance: number,
    senderBlinding: Uint8Array,
    amountBlinding: Uint8Array
): Promise<ZkTransferProof> {
    const pkg = await import('./wasm-generated/gridtokenx_wasm.js');
    await pkg.default();
    const proof = pkg.create_transfer_proof(BigInt(amount), BigInt(balance), senderBlinding, amountBlinding);
    return {
        amount_commitment: proof.amount_commitment,
        amount_range_proof: {
            proof_data: Array.from(proof.amount_range_proof.proof_data),
            commitment: proof.amount_range_proof.commitment
        },
        remaining_range_proof: {
            proof_data: Array.from(proof.remaining_range_proof.proof_data),
            commitment: proof.remaining_range_proof.commitment
        },
        balance_proof: proof.balance_proof
    };
}

export async function benchmarkProofGeneration(): Promise<{ timeMs: number, rounds: number }> {
    const amount = 500;
    const blinding = window.crypto.getRandomValues(new Uint8Array(32));

    const start = performance.now();
    const rounds = 5;

    for (let i = 0; i < rounds; i++) {
        await createRangeProof(amount, blinding);
    }

    const end = performance.now();
    return {
        timeMs: (end - start) / rounds,
        rounds
    };
}
