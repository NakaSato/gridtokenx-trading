import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import { WalletProvider } from "@solana/wallet-adapter-react";
import WalletModal from "../WalletModal";
import { defaultApiClient } from "../../lib/api-client";
import toast from "react-hot-toast";

// Mock dependencies
jest.mock("../../lib/api-client", () => ({
  defaultApiClient: {
    login: jest.fn(),
    register: jest.fn(),
  },
}));

jest.mock("react-hot-toast", () => ({
  success: jest.fn(),
  error: jest.fn(),
}));

// Mock Solana wallet adapter
jest.mock("@solana/wallet-adapter-react", () => ({
  useWallet: () => ({
    select: jest.fn(),
    wallets: [],
    wallet: null,
    publicKey: null,
    connecting: false,
    connected: false,
    disconnecting: false,
  }),
  WalletProvider: ({ children }: { children: React.ReactNode }) => (
    <div>{children}</div>
  ),
}));

// Mock WalletList component
jest.mock("../WalletList", () => {
  return function WalletList({ onWalletConnect, wallets }: any) {
    return (
      <div data-testid="wallet-list">
        {wallets.map((wallet: any) => (
          <button
            key={wallet.id}
            onClick={() => onWalletConnect(wallet.name, wallet.iconPath)}
            data-testid={`wallet-${wallet.id}`}
          >
            {wallet.name}
          </button>
        ))}
      </div>
    );
  };
});

describe("WalletModal", () => {
  const mockOnClose = jest.fn();
  const mockToastSuccess = jest.fn();
  const mockToastError = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    (toast.success as jest.Mock) = mockToastSuccess;
    (toast.error as jest.Mock) = mockToastError;
  });

  describe("Wallet Connection Mode", () => {
    it("renders wallet connection mode by default", () => {
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);

      expect(screen.getByText("Connect Wallet")).toBeInTheDocument();
      expect(screen.getByTestId("wallet-list")).toBeInTheDocument();
      expect(screen.getByText("Or sign in with email →")).toBeInTheDocument();
    });

    it("displays all wallet options", () => {
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);

      expect(screen.getByTestId("wallet-phantom")).toBeInTheDocument();
      expect(screen.getByTestId("wallet-solflare")).toBeInTheDocument();
      expect(screen.getByTestId("wallet-trust")).toBeInTheDocument();
    });

    it("switches to sign in mode when clicking email sign in link", async () => {
      const user = userEvent.setup();
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);

      const signInLink = screen.getByText("Or sign in with email →");
      await user.click(signInLink);

      expect(
        screen.getByRole("button", { name: "Sign In" })
      ).toBeInTheDocument();
      expect(screen.getByLabelText("Username")).toBeInTheDocument();
      expect(screen.getByLabelText("Password")).toBeInTheDocument();
    });
  });

  describe("Sign In Mode", () => {
    beforeEach(() => {
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);
      const signInLink = screen.getByText("Or sign in with email →");
      fireEvent.click(signInLink);
    });

    it("renders sign in form with all fields", () => {
      expect(
        screen.getByRole("button", { name: "Sign In" })
      ).toBeInTheDocument();
      expect(screen.getByLabelText("Username")).toBeInTheDocument();
      expect(screen.getByLabelText("Password")).toBeInTheDocument();
      expect(screen.getByLabelText("Remember me")).toBeInTheDocument();
      expect(screen.getByText("Forgot password?")).toBeInTheDocument();
    });

    it("shows validation error when submitting empty form", async () => {
      const user = userEvent.setup();
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.click(signInButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Please fill in all fields"
        );
      });
    });

    it("validates username length", async () => {
      const user = userEvent.setup();
      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "ab"); // Too short
      await user.type(passwordInput, "password123");
      await user.click(signInButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Username must be between 3 and 50 characters"
        );
      });
    });

    it("validates password length", async () => {
      const user = userEvent.setup();
      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "short"); // Too short
      await user.click(signInButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Password must be between 8 and 128 characters"
        );
      });
    });

    it("successfully logs in with valid credentials", async () => {
      const user = userEvent.setup();
      const mockLoginResponse = {
        data: {
          access_token: "test-token-123",
          token_type: "Bearer" as const,
          expires_in: 86400,
          user: {
            username: "testuser",
            email: "test@example.com",
            role: "user",
            blockchain_registered: false,
          },
        },
        status: 200,
      };

      (defaultApiClient.login as jest.Mock).mockResolvedValue(
        mockLoginResponse
      );

      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "password123");
      await user.click(signInButton);

      await waitFor(() => {
        expect(defaultApiClient.login).toHaveBeenCalledWith(
          "testuser",
          "password123"
        );
        expect(mockToastSuccess).toHaveBeenCalledWith(
          "Welcome back, testuser!"
        );
        expect(mockOnClose).toHaveBeenCalled();
      });
    });

    it("handles 401 unauthorized error", async () => {
      const user = userEvent.setup();
      const mockErrorResponse = {
        error: "Invalid credentials",
        status: 401,
      };

      (defaultApiClient.login as jest.Mock).mockResolvedValue(
        mockErrorResponse
      );

      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "wrongpassword");
      await user.click(signInButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith("Invalid credentials");
      });
    });

    it("handles 403 email not verified error", async () => {
      const user = userEvent.setup();
      const mockErrorResponse = {
        error: "Email not verified",
        status: 403,
      };

      (defaultApiClient.login as jest.Mock).mockResolvedValue(
        mockErrorResponse
      );

      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "password123");
      await user.click(signInButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Email not verified. Please verify your email first."
        );
      });
    });

    it("stores token in sessionStorage when remember me is not checked", async () => {
      const user = userEvent.setup();
      const mockLoginResponse = {
        data: {
          access_token: "test-token-123",
          token_type: "Bearer" as const,
          expires_in: 86400,
          user: {
            username: "testuser",
            email: "test@example.com",
            role: "user",
            blockchain_registered: false,
          },
        },
        status: 200,
      };

      (defaultApiClient.login as jest.Mock).mockResolvedValue(
        mockLoginResponse
      );

      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "password123");
      await user.click(signInButton);

      await waitFor(() => {
        expect(sessionStorage.setItem).toHaveBeenCalledWith(
          "access_token",
          "test-token-123"
        );
        expect(sessionStorage.setItem).toHaveBeenCalledWith(
          "user",
          JSON.stringify(mockLoginResponse.data.user)
        );
      });
    });

    it("stores token in localStorage when remember me is checked", async () => {
      const user = userEvent.setup();
      const mockLoginResponse = {
        data: {
          access_token: "test-token-123",
          token_type: "Bearer" as const,
          expires_in: 86400,
          user: {
            username: "testuser",
            email: "test@example.com",
            role: "user",
            blockchain_registered: false,
          },
        },
        status: 200,
      };

      (defaultApiClient.login as jest.Mock).mockResolvedValue(
        mockLoginResponse
      );

      const usernameInput = screen.getByLabelText("Username");
      const passwordInput = screen.getByLabelText("Password");
      const rememberMeCheckbox = screen.getByLabelText("Remember me");
      const signInButton = screen.getByRole("button", { name: "Sign In" });

      await user.type(usernameInput, "testuser");
      await user.type(passwordInput, "password123");
      await user.click(rememberMeCheckbox);
      await user.click(signInButton);

      await waitFor(() => {
        expect(localStorage.setItem).toHaveBeenCalledWith(
          "access_token",
          "test-token-123"
        );
        expect(localStorage.setItem).toHaveBeenCalledWith(
          "user",
          JSON.stringify(mockLoginResponse.data.user)
        );
      });
    });

    it("toggles password visibility", async () => {
      const user = userEvent.setup();
      const passwordInput = screen.getByLabelText(
        "Password"
      ) as HTMLInputElement;
      const toggleButton = screen.getByLabelText("Show password");

      expect(passwordInput.type).toBe("password");

      await user.click(toggleButton);
      expect(passwordInput.type).toBe("text");

      await user.click(screen.getByLabelText("Hide password"));
      expect(passwordInput.type).toBe("password");
    });

    it("switches to sign up mode", async () => {
      const user = userEvent.setup();
      const signUpLink = screen.getByText("Sign up");

      await user.click(signUpLink);

      expect(
        screen.getByRole("button", { name: "Sign Up" })
      ).toBeInTheDocument();
    });
  });

  describe("Sign Up Mode", () => {
    beforeEach(() => {
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);
      fireEvent.click(screen.getByText("Or sign in with email →"));
      fireEvent.click(screen.getByText("Sign up"));
    });

    it("renders sign up form with all required fields", () => {
      expect(
        screen.getByRole("button", { name: "Sign Up" })
      ).toBeInTheDocument();
      expect(screen.getByLabelText("Username")).toBeInTheDocument();
      expect(screen.getByLabelText("First Name")).toBeInTheDocument();
      expect(screen.getByLabelText("Last Name")).toBeInTheDocument();
      expect(screen.getByLabelText("Email Address")).toBeInTheDocument();
      expect(screen.getByLabelText("Password")).toBeInTheDocument();
      expect(screen.getByLabelText("Confirm Password")).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: "Sign Up" })
      ).toBeInTheDocument();
    });

    it("validates all required fields", async () => {
      const user = userEvent.setup();
      const signUpButton = screen.getByRole("button", { name: "Sign Up" });

      await user.click(signUpButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Please fill in all required fields"
        );
      });
    });

    it("validates email format", async () => {
      const user = userEvent.setup();

      await user.type(screen.getByLabelText("Username"), "testuser");
      await user.type(screen.getByLabelText("First Name"), "John");
      await user.type(screen.getByLabelText("Last Name"), "Doe");
      await user.type(screen.getByLabelText("Email Address"), "invalid-email");
      await user.type(screen.getByLabelText("Password"), "password123");
      await user.type(screen.getByLabelText("Confirm Password"), "password123");
      await user.click(
        screen.getByRole("checkbox", { name: /I agree to the/i })
      );
      await user.click(screen.getByRole("button", { name: "Sign Up" }));

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Please enter a valid email address"
        );
      });
    });

    it("validates password match", async () => {
      const user = userEvent.setup();

      await user.type(screen.getByLabelText("Username"), "testuser");
      await user.type(screen.getByLabelText("First Name"), "John");
      await user.type(screen.getByLabelText("Last Name"), "Doe");
      await user.type(
        screen.getByLabelText("Email Address"),
        "test@example.com"
      );
      await user.type(screen.getByLabelText("Password"), "password123");
      await user.type(
        screen.getByLabelText("Confirm Password"),
        "different123"
      );
      await user.click(
        screen.getByRole("checkbox", { name: /I agree to the/i })
      );
      await user.click(screen.getByRole("button", { name: "Sign Up" }));

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith("Passwords do not match");
      });
    });

    it("requires terms agreement", async () => {
      const user = userEvent.setup();

      await user.type(screen.getByLabelText("Username"), "testuser");
      await user.type(screen.getByLabelText("First Name"), "John");
      await user.type(screen.getByLabelText("Last Name"), "Doe");
      await user.type(
        screen.getByLabelText("Email Address"),
        "test@example.com"
      );
      await user.type(screen.getByLabelText("Password"), "password123");
      await user.type(screen.getByLabelText("Confirm Password"), "password123");
      // Don't click terms checkbox
      await user.click(screen.getByRole("button", { name: "Sign Up" }));

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith(
          "Please agree to the terms and conditions"
        );
      });
    });

    it("successfully registers with valid data", async () => {
      const user = userEvent.setup();
      const mockRegisterResponse = {
        data: {
          access_token: "test-token-123",
          token_type: "Bearer" as const,
          expires_in: 86400,
          user: {
            username: "testuser",
            email: "test@example.com",
            role: "user",
            blockchain_registered: false,
          },
        },
        status: 201,
      };

      (defaultApiClient.register as jest.Mock).mockResolvedValue(
        mockRegisterResponse
      );

      await user.type(screen.getByLabelText("Username"), "testuser");
      await user.type(screen.getByLabelText("First Name"), "John");
      await user.type(screen.getByLabelText("Last Name"), "Doe");
      await user.type(
        screen.getByLabelText("Email Address"),
        "test@example.com"
      );
      await user.type(screen.getByLabelText("Password"), "password123");
      await user.type(screen.getByLabelText("Confirm Password"), "password123");
      await user.click(
        screen.getByRole("checkbox", { name: /I agree to the/i })
      );
      await user.click(screen.getByRole("button", { name: "Sign Up" }));

      await waitFor(() => {
        expect(defaultApiClient.register).toHaveBeenCalledWith({
          username: "testuser",
          email: "test@example.com",
          password: "password123",
          first_name: "John",
          last_name: "Doe",
          role: "user",
        });
        expect(mockToastSuccess).toHaveBeenCalledWith("Welcome, testuser!");
        expect(mockOnClose).toHaveBeenCalled();
      });
    });

    it("handles registration errors", async () => {
      const user = userEvent.setup();
      const mockErrorResponse = {
        error: "User already exists",
        status: 400,
      };

      (defaultApiClient.register as jest.Mock).mockResolvedValue(
        mockErrorResponse
      );

      await user.type(screen.getByLabelText("Username"), "existinguser");
      await user.type(screen.getByLabelText("First Name"), "John");
      await user.type(screen.getByLabelText("Last Name"), "Doe");
      await user.type(
        screen.getByLabelText("Email Address"),
        "existing@example.com"
      );
      await user.type(screen.getByLabelText("Password"), "password123");
      await user.type(screen.getByLabelText("Confirm Password"), "password123");
      await user.click(
        screen.getByRole("checkbox", { name: /I agree to the/i })
      );
      await user.click(screen.getByRole("button", { name: "Sign Up" }));

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalledWith("User already exists");
      });
    });

    it("switches back to sign in mode", async () => {
      const user = userEvent.setup();
      const signInLink = screen.getByText("Sign in");

      await user.click(signInLink);

      expect(
        screen.getByRole("button", { name: "Sign In" })
      ).toBeInTheDocument();
    });
  });

  describe("Modal Behavior", () => {
    it("does not render when isOpen is false", () => {
      render(<WalletModal isOpen={false} onClose={mockOnClose} />);

      expect(screen.queryByText("Connect Wallet")).not.toBeInTheDocument();
    });

    it("calls onClose when dialog is closed", async () => {
      const user = userEvent.setup();
      render(<WalletModal isOpen={true} onClose={mockOnClose} />);

      // The Dialog component's onOpenChange will call onClose
      // This is handled by the Dialog component itself
      expect(mockOnClose).not.toHaveBeenCalled();
    });
  });
});
